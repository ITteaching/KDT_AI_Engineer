## 7.4 SQL 프로그래밍

# [실습 15 : 41p]

### 7.4.1 IF  --- ELSE --- 구문

* IF 구문 예제

```SQL
-- 프로시저 생성 : ifProc
DROP PROCEDURE IF EXISTS ifProc;
DELIMITER $$
CREATE PROCEDURE ifProc()
BEGIN

	DECLARE var1 INT;
	SET var1 = 100;
	
	IF var1 = 100 THEN
		SELECT '100과 일치';
	ELSE
		SELECT '100이 아님';
	END IF;

END $$
DELIMITER ;

-- 프로시저 실행
CALL ifProc();
```

* 테이블 특정 데이타의 조건 확인 예제

  : exployees.employees 테이블, 사번(emp_no)) = 10001, 입사일 5년이 넘었는지 확인

```SQL
-- 프로시저 생성 : ifProc2
USE employees;
DROP PROCEDURE IF EXISTS ifProc2;

DELIMITER $$
CREATE PROCEDURE ifProc2()
BEGIN

	DECLARE hireDate DATE;
	DECLARE days INT;
	
	SELECT hire_date INTO hireDate
	  FROM employees
	 WHERE emp_no = 10001;
	
    SET days = DATEDIFF(CURDATE(), hireDate);
    
	IF (days/365) >= 5 THEN
		SELECT CONCAT('입사한지 5년 이상 : ', days, '일 지났습니다.');
	ELSE
		SELECT CONCAT('입사한지 5년 미만 : ', days, '일 지났습니다.');	
	END IF;
    
END $$
DELIMITER ;

-- 프로시저 실행
CALL ifProc2();
```



# [실습 16 : 42p]

### 7.4.2 CASE

* CASE 문 활용한 학점 등급 출력
* 90점 이상 : 'A', 80점 이상 : 'B', 70점 이상 : 'C', 60점 이상 : 'D', 60점 미만 : 'F' 출력

```SQL
USE SQLDB;
DROP PROCEDURE IF EXISTS caseProc;
DELIMITER $$
CREATE PROCEDURE caseProc()
BEGIN
	
	DECLARE point INT;
	DECLARE credit CHAR(1);
	SET point = 77;
	
	CASE
		WHEN point >= 90 THEN SET credit = 'A';
		WHEN point >= 80 THEN SET credit = 'B';
		WHEN point >= 70 THEN SET credit = 'C';
		WHEN point >= 60 THEN SET credit = 'D';
		ELSE 				  SET credit = 'F';
	END CASE;

	SELECT CONCAT('point : ', point, 'credit : ', credit);
	
END $$
DELIMITER ;

CALL caseProc();
```

### [교재 실습] CASE문 활용 (p288 ~ 292)

* userID별 구매액(price*amount)을 구하는 SQL문 작성, 구매액이 높은 순으로

```SQL
-- buyTBL에서 구매한 userID별 구매액 조회 쿼리
USE sqlDB;
SELECT userID, SUM(price*amount)
  FROM buyTBL
GROUP BY userID
ORDER BY SUM(price*amount) DESC;

-- 구매경험이 없는 userID까지 포함하는 쿼리
SELECT u.userID, sum(B.price*B.amount)
  FROM buyTBL B
 	RIGHT OUTER JOIN userTBL U
 	ON B.userID = U.userID
GROUP BY u.userID
ORDER BY sum(B.price*B.amount) DESC;
```

* 구매액이 1500원 이상이면 'VVIP', 1000원 이상이면 'VIP', 구매이력 있으면 'NORMAL', 구매이력 없으면 'GHOST' 출력

```SQL
-- 구매경험이 없는 userID까지 포함하는 쿼리
SELECT U.userID, sum(B.price*B.amount),
		CASE
			WHEN (sum(B.price*B.amount) >= 15000) THEN 'VVIP'
			WHEN (sum(B.price*B.amount) >= 10000) THEN 'VIP'
			WHEN (sum(B.price*B.amount) >= 1) THEN 'NORMAL'
			ELSE 'GHOST'
		END
  FROM buyTBL B
 	RIGHT OUTER JOIN userTBL U
 	ON B.userID = U.userID
GROUP BY U.userID
ORDER BY sum(B.price*B.amount) DESC;
```



# [실습 17 : 43p]

### 7.4.3 WHILE과 ITERATE/LEAVE

* WHILE 구문 형식

```SQL
WHILE <부울 식> DO
	SQL 명령문들
END WHILE;
```

* WHILE 구문 실습 : 1~100까지 합 계산

```SQL
-- whileProc 프로시저 생성
DROP PROCEDURE IF EXISTS whileProc;
DELIMITER $$
CREATE PROCEDURE whileProc()
BEGIN

	DECLARE i INT;
	DECLARE hap INT;
	
	SET i = 0;
	SET hap = 0;
	
	WHILE i < 100 DO
		SET i = i + 1;
		SET hap = hap + i;
	END WHILE;
	
	SELECT hap;
	
END $$
DELIMITER ;

-- 프로시저 실행
CALL whileProc();
```

* WHILE ITERATE/LEAVE 구문 실습 : 1~100까지 합 계산, 7의 배수 제외, 합이 1000 넘는 경우 종료

```SQL
-- whileProc 프로시저 생성
DROP PROCEDURE IF EXISTS whileProc2;
DELIMITER $$
CREATE PROCEDURE whileProc2()
BEGIN

	DECLARE i INT;
	DECLARE hap INT;
	
	SET i = 0;
	SET hap = 0;
	
	myWhile: WHILE i <= 100 DO
		SET i = i + 1;
    	IF (i%7 = 0) THEN
      		ITERATE myWhile;
		END IF;

		SET hap = hap + i;
 		IF hap > 1000 THEN
 			LEAVE myWhile;
 		END IF;
	END WHILE;
	
	SELECT hap;
	
END $$
DELIMITER ;

-- 프로시저 실행
CALL whileProc2();
```



# [실습 18 : 44 ~ 45p]

### 7.4.4 오류 처리

* 오류 발생 시 처리 구문

```SQL
-- 액션 : CONTINUE, EXIT
-- 오류조건 : SQLEXCEPTION SQLWARNING, NOT FOUND (커서나 SELECT INTO에서 발생하는 오류)
-- 처리문장 : 오류 발생시 처리 문장 ,2문장 이상일 경우 BEGIN --- END 로 묶어줌
DECLARE 액션 HANDLER FOR 오류조건 처리문장;
```

* 오류 발생 시 처리 구문 예제

```SQL
-- errorProc 프로시저 생성
DROP PROCEDURE IF EXISTS errorProc;
DELIMITER $$
CREATE PROCEDURE errorProc()
BEGIN
	DECLARE a CHAR(8);
	DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
	BEGIN
		SHOW ERRORS;
		ROLLBACK;
	END;
	
	INSERT INTO userTBL(userID, name, birthYear, addr, mobile1, mobile2, height, mDate)
	 		VALUES ('LSG', '이상구', 1988, '서울', NULL, NULL, 170, CURRENT_DATE());
 		
END $$
DELIMITER ;

-- 프로시저 실행
CALL errorProc();
```



# [실습 19 : 46p]

### 7.4.5 동적 SQL

* 쿼리문장을 변수에 담아 실행함 : 쿼리문장내 조건값 등을 동적으로 할당 가능함

```SQL
-- 표준 구문
-- PREPARE 선언
-- EXECUTE 실행
-- DEALLOCATE PREPARE 제거
USE sqlDB
PREPARE myQuery FROM 'SELECT * FROM userTBL WHERE userID = "EJW"';
EXECUTE myQuery;
DEALLOCATE PREPARE myQuery;

-- userID와 mobile1의 조건값 변수로 할당
USE sqlDB
SET @userID = 'BBK';
SET @mobile1 = '010';
PREPARE myQuery FROM 'SELECT * FROM userTBL WHERE userID = ? AND mobile1 = ?';
EXECUTE myQuery USING @userID, @mobile1;
DEALLOCATE PREPARE myQuery;

-- sql문을 사전에 만들어서 실행하는 방법
SET @userID = 'BBK';
SET @vsql = CONCAT('SELECT * FROM userTBL WHERE userid = "', @userID, '"');
SELECT @vsql;

PREPARE myQuery FROM @vsql;
EXECUTE myQuery;
DEALLOCATE PREPARE myQuery;
```

