# 11. 전체 텍스트 검색과 파티션

## 11.1 전체 텍스트 검색



# [실습 1 : 5 ~ 7p]

* step1) 검색 데이타베이스 및 테이블 생성

```SQL
-- 데이타베이스 생성
CREATE DATABASE IF NOT EXISTS FulltextDB;
USE FulltextDB;

-- 테이블 생성
DROP TABLE IF EXISTS FulltextTbl;
CREATE TABLE FulltextTbl ( 
	id int AUTO_INCREMENT PRIMARY KEY, 	-- 고유 번호
	title VARCHAR(15) NOT NULL, 		-- 영화 제목
	description VARCHAR(1000)  		-- 영화 내용 요약
);

-- 데이타 입력
INSERT INTO FulltextTbl VALUES
(NULL, N'광해, 왕이 된 남자', N'왕위를 둘러싼 권력 다툼과 당쟁으로 혼란이 극에 달한 광해군 8년'),
(NULL, N'간첩', N'남한 내에 고장간첩 5만 명이 암약하고 있으며 특히 권력 핵심부에도 침투해있다.'),
(NULL, N'남자가 사랑할 때', N'대책 없는 한 남자이야기. 형 집에 얹혀 살며 조카한테 무시당하는 남자'),
(NULL, N'레지던트 이블 5', N'인류 구원의 마지막 퍼즐, 이 여자가 모든 것을 끝낸다.'),
(NULL, N'파괴자들', N'사랑은 모든 것을 파괴한다! 한 여자를 구하기 위한, 두 남자의 잔인한 액션 본능!'),
(NULL, N'킹콩을 들다', N' 역도에 목숨을 건 시골소녀들이 만드는 기적 같은 신화.'),
(NULL, N'테드', N'지상최대 황금찾기 프로젝트! 500년 전 사라진 황금도시를 찾아라!'),
(NULL, N'타이타닉', N'비극 속에 침몰한 세기의 사랑, 스크린에 되살아날 영원한 감동'),
(NULL, N'8월의 크리스마스', N'시한부 인생 사진사와 여자 주차 단속원과의 미묘한 사랑'),
(NULL, N'늑대와 춤을', N'늑대와 친해져 모닥불 아래서 함께 춤을 추는 전쟁 영웅 이야기'),
(NULL, N'국가대표', N'동계올림픽 유치를 위해 정식 종목인 스키점프 국가대표팀이 급조된다.'),
(NULL, N'쇼생크 탈출', N'그는 누명을 쓰고 쇼생크 감옥에 감금된다. 그리고 역사적인 탈출.'),
(NULL, N'인생은 아름다워', N'귀도는 삼촌의 호텔에서 웨이터로 일하면서 또 다시 도라를 만난다.'),
(NULL, N'사운드 오브 뮤직', N'수녀 지망생 마리아는 명문 트랩가의 가정교사로 들어간다'),
(NULL, N'매트릭스', N' 2199년.인공 두뇌를 가진 컴퓨터가 지배하는 세계.');

-- 인덱스 없는 경우 '남자' 단어 검색
SELECT * FROM FulltextTbl WHERE description LIKE '%남자%';

EXPLAIN SELECT * FROM FulltextTbl WHERE description LIKE '%남자%';
```

* step2) 전체 텍스트 인덱스 생성

```SQL
-- 전체 텍스트 인덱스 생성 create fulltext
CREATE FULLTEXT INDEX idx_description
ON FullTextTbl(description);

-- 정보 확인
SHOW INDEX FROM FulltextTbl;

-- 전체 텍스트 인덱스 삭제
DROP INDEX idx_fulltexttbl_description
	ON fulltexttbl;
	
-- 전체 텍스트 인덱스 생성 : alter table	
ALTER TABLE fulltextTBL
	ADD FULLTEXT idx_fulltexttbl_description(description);
	
-- 정보 확인
SHOW INDEX FROM FulltextTbl;	
```



# [실습 2 : 8 ~ 14p]

* step3) 전체 텍스트 인덱스 활용한 검색

```SQL
-- '남자' 포함된 데이타 조회
SELECT * FROM FulltextTbl WHERE MATCH(description) AGAINST('남자');
SELECT * FROM FulltextTbl WHERE MATCH(description) AGAINST('남자' IN BOOLEAN MODE);

-- '남자' 또는 '여자' 단어가 있는 데이타 조회
SELECT * FROM FulltextTbl WHERE MATCH(description) AGAINST('남자 여자');
SELECT * FROM FulltextTbl WHERE MATCH(description) AGAINST('남자 여자' IN BOOLEAN MODE);

-- '남자'로 시작하는 단어가 포함된 데이타 조회
SELECT * FROM FulltextTbl WHERE MATCH(description) AGAINST('남자*' IN BOOLEAN MODE);

-- '남자' 또는 '여자'로 시작하는 단어가 포함된 데이타 조회
SELECT * FROM FULLTEXTTBL WHERE MATCH(description) AGAINST('남자* 여자*' IN BOOLEAN MODE);

-- EXPLAIN 확인 : 인덱스 활용 확인
EXPLAIN SELECT * FROM FulltextTbl WHERE MATCH(description) AGAINST('남자*' IN BOOLEAN MODE);

-- '남자' OR '여자'가 포함된 행 검색, 매치 점수 출력
-- 매치 점수 : 동일한 단어는 여러번 나와도 한번으로 점수화함
SELECT *, MATCH(description) AGAINST('남자* 여자*' IN BOOLEAN MODE) AS 점수
  FROM FulltextTbl
 WHERE MATCH(description) AGAINST('남자* 여자*' IN BOOLEAN MODE);

-- '남자' AND '여자'가 포함된 행 검색, 매치 점수 출력
SELECT *
  FROM FulltextTbl
 WHERE MATCH(description) AGAINST('+남자* +여자*' IN BOOLEAN MODE);
 
-- '남자' 포함 AND '여자' 제외 행 검색, 매치 점수 출력
SELECT *
  FROM FulltextTbl
 WHERE MATCH(description) AGAINST('남자* -여자*' IN BOOLEAN MODE); 
```

* step4) 전체 텍스트 인덱스가 생성된 '단어', '문구' 확인

```SQL
-- 전체 텍스트 인덱스로 만들어진 단어 확인
SET GLOBAL innodb_ft_aux_table = 'fulltextdb/fulltexttbl';
SELECT word, doc_count, doc_id, position
  FROM INFORMATION_SCHEMA.INNODB_FT_INDEX_TABLE;
  
-- 중지(제외) 단어 설정  
-- 전체 텍스트 인덱스 삭제
DROP INDEX idx_description ON FulltextTbl;

-- 중지(제외) 단어 테이블 생성 (컬럼명은 반드시 소문자 'value'이어야만 함)
CREATE TABLE user_stopword (value VARCHAR(30));

-- 중지(제외) 단어 테이블 입력
INSERT INTO user_stopword VALUES('그는'), ('그리고'), ('극에');

-- innodb GLOBAL 변수 설정 및 확인
SET GLOBAL innodb_ft_server_stopword_table = 'fulltextdb/user_stopword';
SHOW GLOBAL VARIABLES LIKE 'innodb_ft_server_stopword_table';

-- 전체 텍스트 인덱스 생성
CREATE FULLTEXT INDEX idx_description ON FulltextTbl(description);

-- 전체 텍스트 인덱스로 만들어진 단어 확인
SELECT word, doc_count, doc_id, position
  FROM INFORMATION_SCHEMA.INNODB_FT_INDEX_TABLE;
```



## 11.2 파티션

# [실습 3 : 15 ~ 18p] : 교재 469 ~ 473

* partDB 데이타베이스 생성

```SQL
CREATE DATABASE IF NOT EXISTS partDB;
USE partDB;
```

### 1) 파티션 생성

* range 파티션 생성

```SQL
-- 테이블 생성
-- userID를 PRIMARY KEY로 지정 불가 : userID로 정렬되면 파티션을 나눌 수 없음
-- userID와 birthYear를 PRIMARY KEY로 지정해야 함
DROP TABLE IF EXISTS partTBL;
CREATE TABLE partTBL(
    userID CHAR(8) NOT NULL,
    name VARCHAR(10) NOT NULL,
    birthYear INT NOT NULL,
    addr CHAR(2) NOT NULL
)
PARTITION BY RANGE(birthYear)(
	PARTITION part1 VALUES LESS THAN (1971),
	PARTITION part2 VALUES LESS THAN (1979),
	PARTITION part3 VALUES LESS THAN MAXVALUE
);

-- PRIMARY KEY 지정 : PARTITION KEY 포함될 경우 생성 가능
CREATE TABLE partTBL(
	userID	CHAR(8) NOT NULL,
	name	VARCHAR(10) NOT NULL,
	birthYear INT NOT NULL,
	addr	CHAR(2) NOT NULL,
	PRIMARY KEY (userid, birthyear)
)
PARTITION BY RANGE(birthYear)(
	PARTITION part1 VALUES LESS THAN (1971),
	PARTITION part2 VALUES LESS THAN (1979),
	PARTITION part3 VALUES LESS THAN MAXVALUE
);

```

* list 파티션 생성

```sql
CREATE TABLE partlistTBL(
    userID CHAR(8) NOT NULL,
    name VARCHAR(10) NOT NULL,
    birthYear INT NOT NULL,
    addr CHAR(2) NOT NULL
)
PARTITION BY LIST COLUMNS(addr)(
    PARTITION part1 VALUES IN ('서울', '경기'),
    PARTITION part2 VALUES IN ('충북', '충남'),
    PARTITION part3 VALUES IN ('경북', '경남'),
    PARTITION part4 VALUES IN ('전북', '전남'),
    PARTITION part5 VALUES IN ('강원', '제주')
);
```



# [실습 4 : 19p]

### 2) 파티션 확인

* 데이타 입력

```SQL
-- partTBL INSERT : sqldb.userTBL 데이타로 입력
INSERT INTO partTBL
	SELECT userID, name, birthYear, addr FROM sqlDB.userTBL;

-- 입력 데이타 확인 : 파티션 순서대로 정렬됨
SELECT * FROM partTBL;
```

* 파티션 정보 조회

```SQL
SELECT table_schema, table_name, partition_name, partition_ordinal_position, table_rows
  FROM information_schema.partitions
 WHERE table_name = 'parttbl';
```

* 파티션 범위 지정 조회 (birthYear <= 1965)

```sql
-- PART1 에서만 조회
SELECT * FROM partTBL WHERE birthYear <= 1965;
EXPLAIN SELECT * FROM partTBL WHERE birthYear <= 1965;
EXPLAIN PARTITIONS SELECT * FROM partTBL WHERE birthYear <= 1965;

-- PART1, PART2 데이타 조회
EXPLAIN PARTITIONS SELECT * FROM partTBL WHERE birthYear <= 1975;
```



# [실습 5 : 20 ~ 21p]

### 3) 파티션 관리

* 파티션 분리 : part3  -> part3, part4

```SQL
ALTER TABLE partTBL
	REORGANIZE PARTITION part3 INTO(
        		PARTITION part3 VALUES LESS THAN (1986),
				PARTITION part4 VALUES LESS THAN MAXVALUE
);		
-- OPTIMIZE를 통해 조건에 맞게 데이타 및 스토리지 재구성
OPTIMIZE TABLE partTBL;
-- 파티션 정보 확인
SELECT table_schema, table_name, partition_name, partition_ordinal_position, table_rows
  FROM information_schema.partitions
 WHERE table_name = 'parttbl';
```

* 파티션 합치기 : part1 + part2 => part12

```sql
ALTER TABLE partTBL
	REORGANIZE PARTITION part1, part2 INTO(
    			PARTITION part12 VALUES LESS THAN (1979)
    );
    
-- OPTIMIZE를 통해 조건에 맞게 데이타 재구성
OPTIMIZE TABLE partTBL;

-- 파티션 정보 확인
SELECT table_schema, table_name, partition_name, partition_ordinal_position, table_rows
  FROM information_schema.partitions
 WHERE table_name = 'parttbl';
```

* 파티션 삭제 : part12

```sql
ALTER TABLE partTBL DROP PARTITION part12;

-- OPTIMIZE를 통해 조건에 맞게 데이타 재구성
OPTIMIZE TABLE partTBL;

-- partition 삭제 시 해당 데이타 모두 삭제됨
SELECT * FROM partTBL;
```

