# [실습 1 : 7p] 클러스터형 인덱스 생성 (p360 ~ 364)

* 클러스터형 인덱스 생성 시 데이타는 해당 인덱스 순으로 정렬된다
* primary key, unique and not null index
* 테이블 생성

```SQL
-- userTBL 생성
USE SQLDB;

DROP TABLE IF EXISTS userTBL;
CREATE TABLE userTBL
( userID     CHAR(8) NOT NULL primary key,
  name       VARCHAR(10) NOT NULL, 	
  birthYear  INT NOT NULL,		
  addr       CHAR(2) NOT NULL	
);
```

* 데이타 입력

```SQL
-- 5건 데이타 입력
INSERT INTO usertbl VALUES('LSG', '이승기', 1987, '서울');
INSERT INTO usertbl VALUES('KBS', '김범수', 1979, '경남');
INSERT INTO usertbl VALUES('KKH', '김경호', 1971, '전남');
INSERT INTO usertbl VALUES('JYP', '조용필', 1950, '경기');
INSERT INTO usertbl VALUES('SSK', '성시경', 1979, '서울');

-- userID순으로 정렬되어 보임 (userid가 클러스터 인덱스임)
SELECT * FROM usertbl;
```

- PRIMARY KEY를 'NAME'으로 변경

```SQL
-- PRIMARY KEY DROP 후 name으로 재생성
ALTER TABLE usertbl DROP PRIMARY KEY;
ALTER TABLE usertbl ADD PRIMARY KEY(name);

-- name 순으로 정렬되어 보임 (name이 클러스터 인덱스임)
SELECT * FROM usertbl;
```



# [실습 2 : 8 ~ 11p]  인덱스 생성 및 활용 (p385~391)

* 인덱스 확인

```SQL
USE SQLDB;
SHOW INDEX FROM userTBL;
SHOW TABLE STATUS LIKE 'userTBL';
```

- 보조 인덱스 생성

```SQL
-- addr 보조 인덱스 생성
CREATE INDEX idx_userTBL_addr
ON userTBL (addr);
-- SHOW TABLE STATUS LIKE 'userTBL';

-- 테이블 현황 통계 테이블에 적용
ANALYZE TABLE userTBL;
SHOW TABLE STATUS LIKE 'userTBL';
```

* birthYear 고유 보조인덱스 생성

```SQL
-- birthYear 컬럼에 1979가 2건 존재하여 인덱스 생성 오류 발생
CREATE UNIQUE INDEX idx_userTBL_birthYear
ON userTBL (birthYear);
```

* name 고유 보조인덱스 생성

```SQL
-- nmae 고유 보조인덱스 생성
CREATE UNIQUE INDEX idx_userTBL_name
ON userTBL (name); 

-- 동명이인 insert 시 오류 발생
INSERT INTO usertbl VALUES('GPS', '김범수', 1983);
```

- 조합인덱스 생성

```SQL
-- 조합 컬럼 : name, birthYear
CREATE INDEX idx_userTBL_name_birthYear
ON userTBL(name, birthYear);

-- name 보조 인덱스 삭제 : name으로 시작하는 조합인덱스가 있으므로 무의미
DROP INDEX idx_userTBL_name ON userTBL;
```

* EXPLAIN 확인

```SQL
-- 조합인덱스의 모든 컬럼이 조회 조건에 있을 경우
EXPLAIN SELECT * FROM usertbl WHERE name='김범수' AND birthYear='1979';

-- 조합인덱스중 시작 컬럼만 조회 조건에 있을 경우
EXPLAIN SELECT * FROM usertbl WHERE name='김범수';

-- 조회조건 데이터에 따라 TABLE FULL SCAN과 INDEX 사용은 DBMS에서 결정
EXPLAIN SELECT * FROM usertbl WHERE ADDR='서울';   -- table full scan
EXPLAIN SELECT * FROM usertbl WHERE ADDR='경북'; 
```

* 외래 키 제약 조건 이름 확인

```SQL
SELECT table_name, constraint_name
  FROM information_schema.referential_constraints
 WHERE constraint_schema = 'sqlDB';
```



# [실습 3 : 12 ~ 13] 인덱스 성능 비교 (p392~406)

- 인덱스가 없을 경우, 클러스터형 인덱스만 있을 때, 보조 인덱스만 있을 때의 성능 비교
- Table 생성

```SQL
-- DATABASE 생성 : indexDB
CREATE DATABASE indexDB;
USE indexDB;

-- employees의 employees table 복사
SELECT count(*) FROM employees.employees;
CREATE TABLE Emp SELECT * FROM employees.employees ORDER BY RAND();
CREATE TABLE Emp_C SELECT * FROM employees.employees ORDER BY RAND();
CREATE TABLE Emp_SE SELECT * FROM employees.employees ORDER BY RAND();

-- 데이타 확인
SELECT * FROM Emp LIMIT 5;
SELECT * FROM Emp_C LIMIT 5;
SELECT * FROM Emp_Se LIMIT 5;

-- 인덱스 생성여부 확인
-- 3개 테이블 모두 인덱스가 없음
SHOW TABLE STATUS;
```

- 인덱스 생성

```SQL
-- EMP_C : Primary Key
ALTER TABLE Emp_C ADD PRIMARY KEY(emp_no);
-- EMP_Se : 보조 인덱스
CREATE INDEX idx_emp_no ON Emp_Se(emp_no);
```

* Explain 확인

```SQL
-- 데이타 건수 확인 : emp_no = 100000
-- 1건 조회
SELECT * FROM Emp WHERE emp_no = 100000;

-- EXPLAIN 확인 : 3개 테이블
EXPLAIN SELECT * FROM Emp WHERE emp_no = 100000;
EXPLAIN SELECT * FROM Emp_C WHERE emp_no = 100000;
EXPLAIN SELECT * FROM Emp_Se WHERE emp_no = 100000;

-- 범위 조건으로 데이타 조회 : emp_no < 11000
-- 999건 조회
SELECT * FROM Emp WHERE emp_no < 11000;

-- EXPLAIN 확인 : 3개 테이블
EXPLAIN SELECT * FROM Emp WHERE emp_no < 11000;
EXPLAIN SELECT * FROM Emp_C WHERE emp_no < 11000;
EXPLAIN SELECT * FROM Emp_Se WHERE emp_no < 11000;
```

- 강제로 인덱스 제외

```SQL
-- IGNORE INDEX(idx_emp_no)
EXPLAIN SELECT * FROM Emp_C IGNORE INDEX(PRIMARY) WHERE emp_no < 11000;
EXPLAIN SELECT * FROM Emp_Se IGNORE INDEX(idx_emp_no) WHERE emp_no < 11000;

-- 컬럼 가공시 인덱스 적용되지 않음
EXPLAIN SELECT * FROM Emp_C WHERE emp_no * 1 = 100000;

-- 데이타 가공시 인덱스 적용됨
EXPLAIN SELECT * FROM Emp_C WHERE emp_no = 100000 * 1;
```

- 강제로 인덱스 적용

```SQL
-- USE INDEX(idx_emp_no)
EXPLAIN SELECT * FROM Emp_C USE INDEX(PRIMARY) WHERE emp_no < 11000;
EXPLAIN SELECT * FROM Emp_Se USE INDEX(idx_emp_no) WHERE emp_no < 11000;
```

- 데이터 중복도에 따른 인덱스 효용

```SQL
-- 인덱스 없을 경우
EXPLAIN SELECT * FROM Emp WHERE gender='M';

-- 인덱스 생성
CREATE INDEX idx_gender ON Emp(gender);

-- 인덱스 정보 확인
-- Cardinality가 '2'로 데이타 값의 종류가 2가지 밖에 없음 : index 의미 없음
SHOW INDEX FROM Emp;

-- 테이블 full scan 진행
-- 위 INDEX 생성시보다 더 좋은 성능을 보여줌
EXPLAIN SELECT * FROM Emp WHERE gender='M';
```
