## 7.2 Maria DB의 내장 함수와 윈도 함수

### 7.2.1 MariaDB 내장 함수

# [실습 2 : 11p]

* 제어 흐름 함수 : 프로그램의 흐름을 제어하는 함수

```SQL
-- 1) IF(수식, 값1, 값2)
-- usertbl에서 50세이상인 경우 '50세 이상', 그 외인 경우 '50세 미만' 출력
SELECT name, IF (birthyear <= 1972, '50세 이상', '50세 미만'), birthyear
  FROM usertbl;

-- 2) IFNULL(수식1, 수식2)
-- 수식1, 값이 없으면 수식2 출력
-- usertbl에서 mobile1이 있는 경우 값을, 없는 경우 '연락처 없음' 출력
SELECT name, IFNULL(mobile1, '연락처 없음')
  FROM usertbl;

-- 3) NULLIF(수식1, 수식2)
-- 수식1과 수식2 같은 경우 NULL, 다른 경우 수식1 반환
-- usertbl에서 mobile1이 '010'인 경우 null, 다른 경우 mobile1 반환
SELECT mobile1, NULLIF(mobile1,'010')
  FROM usertbl;

-- 4) CASE ~ WHEN ~ ELSE ~ END
-- usertbl에서 addr이 '서울', '경기'인 경우 수도권으로 변경
SELECT   CASE addr
	WHEN '서울' THEN '수도권'
	WHEN '경기' THEN '수도권'
	ELSE addr
	END,
	name, addr
  FROM 	usertbl;
```



# [실습 3 : 12P]

* 문자열 함수 I

```SQL
-- ASCII(아스키코드), CHAR(숫자)
SELECT ASCII('A');
SELECT CHAR(65);

-- 1) BIT_LENGTH(문자열)- BIT 크기, CHAR_LENGTH(문자열) - 문자갯수, LENGTH(문자열) - Byte수
SELECT BIT_LENGTH('abc'), CHAR_LENGTH('abc'), LENGTH('abc');
SELECT BIT_LENGTH('가나다'), CHAR_LENGTH('가나다'), LENGTH('가나다');

-- 2) CONCAT(문자열1, 문자열2, ...)
-- usertbl에서 mobile1과 mobile2를 하나의 필드로 출력
SELECT name, CONCAT(mobile1, mobile2) 
  FROM usertbl;

-- 3) usertbl에서 mobile1과 mobile2를 하나의 필드로 출력하되 중간에 '-' 삽입
SELECT name, CONCAT_WS('-', mobile1, mobile2) 
  FROM usertbl;

-- 4) ELT(위치, 문자열1, 문자열2)
--    FIELD(찾을 문자열, 문자열1, 문자열2)
--    FIND_IN_SET(찾을 문자열, 문자열 리스트)
--    INSTR(기준 문자열, 부분 문자열)
--    LOCATE(부분 문자열, 기준 문자열) 
-- SELECT ELT(2, '하나', '둘', '셋'), 
--          FIELD('둘', '하나', '둘', '셋'),
--          FIND_IN_SET('둘', '하나,둘,셋'),
--          INSTR('하나둘셋', '둘'),		-- 중요 : 문자열의 위치값(1부터 시작)을 리턴
--          LOCATE('둘', '하나둘셋');

-- 4) INSTR(문자열, 검색어)
SELECT INSTR('APPLE BANANA ORANGE', 'PPL')
```



# [실습 4 : 13P]

* 문자열 함수 II

```SQL
-- 5) FORMAT(숫자, 소수점 자릿수)
SELECT FORMAT(123456.123456, 3);

-- 6) INSERT(기준 문자열, 위치, 길이만큼 삭제, 삽입할 문자열) -- 길이만큼 삭제함
SELECT INSERT ('abcdefghi', 3, 4, '@@@@'), INSERT('abcdefghi', 3, 2, '@@@@');

-- 7) LEFT(문자열, 길이), RIGHT(문자열, 길이)
SELECT LEFT('abcdefghi', 3), RIGHT('abcdefghi', 3);

-- 8) UPPER(문자열), LOWER(문자열)
SELECT LOWER('abcdEFGH'), UPPER('abcdEFGH');

-- 9) LPAD(문자열, 길이, 채울 문자열), RPAD(문자열, 길이, 채울 문자열)
SELECT LPAD('START', 8, '##'), RPAD('END', 6, '##');

-- 10) LTRIM, RTRIM, TRIM : 공백제거
SELECT LTRIM('  TEST  '), RTRIM('    TEST   '), TRIM('   TEST   ');

-- 11) REPEAT(문자열, 횟수) : 문자열 반복
SELECT REPEAT('ABC', 3);
```



# [실습 5 : 14P]

* 문자열 함수 III

```SQL
-- 12) REPLACE(문자열, 원래 문자열, 바꿀 문자열)
SELECT REPLACE('이것이 MariaDB', '이것이', 'This Is');
SELECT name, REPLACE(mobile1, mobile1, '010'), mobile2 FROM userTBL;

-- 13) REVERSE(문자열) : 순서 바꾸기
SELECT REVERSE('1234598765');
SELECT REVERSE(name) FROM userTBL;

-- 14) SPACE(길이) : 공백 출력
SELECT CONCAT('A',SPACE(5),'B');

-- 15) SUBSTRING(문자열, 시작위치, 길이)
-- usertbl의 mobile2에서 앞 4자리만 가져오기, NULL인 경우 '-'으로 출력
SELECT IFNULL(SUBSTRING(mobile2, 1, 4), '-')
  FROM usertbl;

-- 16) SUBSTRING_INDEX(문자열, 구분자, 횟수) : 구분자가 해당 횟수에 나오면 그 이후는 버림
SELECT SUBSTRING_INDEX('www.naver.com', '.', 2),
       SUBSTRING_INDEX('www.naver.com/abc/def/', '/', 1);
```



# [실습 6 : 15 ~ 16p]

* 수학 함수

```SQL
-- 1) ABS(숫자) : 절대값 반환
SELECT ABS(-100);

-- 2) 삼각함수 : SIN(숫자), COS(숫자), TAN(숫자), ACOS(숫자), ASIN(숫자), ATAN(숫자)

-- 3) CEIL(숫자) : 올림, FLOOR(숫자) : 내림, ROUND(숫자) : 반올림
SELECT CEIL(4.7), FLOOR(4.7), ROUND(4.7222, 2);

-- 4) MOD(숫자1, 숫자2) : 숫자1을 숫자2로 나눈 나머지 값 반환
SELECT MOD(15, 4) ;

-- 5) POW(숫자1, 숫자2) : 제곱, SQRT(숫자) : 제곱근
SELECT POW(2,3), SQRT(9);

-- 6) RAND() : 0이상 1 미만의 실수를 구함
SELECT RAND(), FLOOR(1 + (RAND() * (7 - 1)));

-- 7) TRUNCATE(숫자, 정수) : 소숫점의 정수까지만 유지
SELECT TRUNCATE(12345.1234, 2);
```



# [실습 8 : 17p]

* 날짜 및 시간 함수 I

```SQL
-- 1) ADDDATE(날짜, 차이), SUBDATE(날짜, 차이) : 날짜 기준 차이를 더하거나 뺀 날짜 반환
SELECT mdate, ADDDATE(mdate, 10), ADDDATE(mdate, interval 1 month), ADDDATE(mdate, interval 1 year)
  FROM usertbl;

SELECT mdate, SUBDATE(mdate, 10), SUBDATE(mdate, interval 1 month), SUBDATE(mdate, interval 1 year)
  FROM usertbl;

-- 2) ADDTIME(날짜/시간, 시간), SUBTIME(날짜/시간, 시간)
SELECT now(), ADDTIME(now(), '1:1:1'), SUBTIME(now(), '1:1:1');

-- 3) CURDATE() : 연-월-일, CURTIME() : 시-분-초, NOW(), SYSDATE() : 연-월-일 시:분:초
SELECT CURDATE(), CURTIME(), NOW(), SYSDATE();

-- 4) YEAR, MONTH, DAY, HOUR, MINUTE, SECOND, MICROSECOND
-- 날짜 또는 시간에서 연, 월, 일, 시, 분, 초, 밀리초 구하는 함수
SELECT NOW(), YEAR(NOW()), MONTH(NOW()), DAY(NOW()), HOUR(NOW()), MINUTE(NOW()), SECOND(NOW()), MICROSECOND(NOW());
```



# [실습 8 : 18p]

* 날짜 및 시간 함수 II

```SQL
-- 5) DATE(), TIME()
-- DATETIME 형식에서 연-월-일 및 시:분:초만 추출
SELECT NOW(), DATE(NOW()), TIME(NOW());

-- 6) DATEDIFF(날짜1, 날짜2), TIMEDIFF(시간1, 시간2)
SELECT DATEDIFF(NOW(), '2022-01-01'), TIMEDIFF(CURTIME(), '12:10:10')

-- 7) DAYOFWEEK(날짜), MONTHNAME(), DAYOFYEAR(날짜)
-- 현재요일, 월 이름, 1년 중 몇 번째 날인지
SELECT DAYOFWEEK(CURDATE()), MONTHNAME(CURDATE()), DAYOFYEAR(CURDATE());
```



# [실습 8 : 19p]

* 날짜 및 시간 함수 III

```SQL
-- 8) LAST_DAY(날짜)
-- 주어진 날짜의 마지막 날짜 구하기
SELECT LAST_DAY('2022-11-01');

-- 9) MAKEDATE(연도, 정수)
-- 연도에서 정수만큼 지난 날짜 구하기
SELECT MAKEDATE('2022', 50);

-- 10) MAKETIME(시, 분, 초)
-- '시:분:초'의 TIME 형식을 만든다
SELECT MAKETIME(10,11,12);

-- 11) PERIOD_ADD(연월, 개월수) : 연월 + 개월수, PERIOD_DIFF(연월1, 연월2) : 연월1 - 연월2
-- 연월은 YYYY, YYYYMM 형식 사용
SELECT PERIOD_ADD(202209,2), PERIOD_DIFF(202209, 201905);

-- 12) QUARTER(날짜)
-- 날짜가 4분기중 몇 분기인지 반환
SELECT QUARTER(NOW());

-- 13) TIME_TO_SEC(시간)
-- 시간을 초 단위로 구함
SELECT TIME_TO_SEC(CURTIME());
```



# [실습 8 : 20p]

* 시스템 정보 함수

```SQL
-- 1) USER(), DATABASE()
-- 현재 사용자 및 선택된 데이타베이스 확인
SELECT USER(), DATABASE();

-- 2) FOUND_ROWS()
-- 바로 앞의 SELECT문에서 조회된 행의 갯수 확인
SELECT * FROM userTBL;
SELECT FOUND_ROWS();

-- 3) ROW_COUNT()
-- 바로 앞의 INSERT, UPDATE, DELETE문에서 처리한 행의 갯수 확인
-- (CREATE, DROP문 : 0, SELECT : -1)
UPDATE buyTBL SET price = price * 2;
SELECT ROW_COUNT();

-- 4) VERSION()
-- 현재 MariaDB의 버전을 구한다.
SELECT VERSION();

-- 5) SLEEP(초)
-- 쿼리의 실행을 잠깐 멈춘다
SELECT SLEEP(5);
SELECT * FROM userTBL;
```



# [실습 9 : 21 ~ 22p]

- 대용량 TEXT 데이터 입력 및 파일로 저장하기  (교재 247Page)

```SQL
-- 대량의 문자 저장 가능한 TEXT 데이터 형식 실습
-- 1) STEP1 : 대용량 데이터 입력 테이블 정의
CREATE TABLE maxTBL (col1 LONGTEXT, col2 LONGTEXT);

-- 2) STEP2 : 1,000,000(백만)개 문자 대량 데이터 입력
INSERT INTO maxTBL VALUES(REPEAT('A', 1000000), REPEAT('가', 1000000));

-- 입력된 크기 확인
SELECT LENGTH(col1), LENGTH(col2), CHAR_LENGTH(col1), CHAR_LENGTH(col2) FROM maxTBL;

-- 3) STEP3 : 10,000,000(천만)개 문자의 대량 데이터 입력
INSERT INTO maxTBL VALUES(REPEAT('A', 10000000), REPEAT('가', 10000000));
-- 에러발생 : ERROR 1301 (HY000): Result of repeat() was larger than max_allowed_packet (16777216) - truncated
-- 16M 까지만 저장 가능 : max_allowed_packet 조정 필요

-- 4) STEP4 : max_allowed_packet 변경
--    . C:\Program Files\MariaDB 10.6\data\my.ini
--      (리눅스 : /etc/my.cnf.d/server.cnf)       
--    . [mysqld] 아래에 "max_allowed_packet=1000M" 추가 후 저장
--    . mariaDB서버 재시작 : net stop mariadb, net start mariadb (작업관리자>서비스->재시작)
--    . mariaDB 접속

-- 5) STEP5 : 10,000,000(천만)개 문자의 대량 데이터 재입력
USE sqlDB
INSERT INTO maxTBL VALUES(REPEAT('A', 10000000), REPEAT('가', 10000000));

-- 6) STEP6 : 쿼리의 결과를 파일로 저장
SELECT * INTO OUTFILE 'C:/work/userTBL.txt' FROM userTBL;

-- 7) STEP7 : 파일의 내용을 userTBL_restore에 입력

CREATE TABLE userTBL_restore LIKE userTBL;  -- 테이블 구조만 복사
// Mariadb command 창에서 실행해야 함
LOAD DATA LOCAL INFILE 'C:/work/userTBL.txt' INTO TABLE userTBL_restore;
```



# [실습 10 : 23p]

* BLOB 형태의 파일 테이블에 입력하고 파일로 저장하기

```SQL
-- 1) STEP1 : BLOB형태의 데이터 입력 테이블 정의
CREATE TABLE blobTBL (col1 VARCHAR(50), col2 LONGBLOB);

-- 2) BLOB 파일 테이블에 저장
INSERT INTO blobTBL(col1, col2)
  VALUES('blob1.png', LOAD_FILE('d:\\temp\\blob1.png'));
  
-- 3) 데이타 확인
SELECT * FROM blobTBL;

-- 4) BLOB 데이타 파일로 저장하기
SELECT col2 INTO DUMPFILE 'd:\\temp\\newblob1.png'
  FROM blobTBL
 WHERE col1 = 'blob1.png';
```



# [실습 11 : 24 ~ 27]

### 7.2.2 MariaDB 윈도우 함수[참고만]

* 행과 행 사이의 관계를 쉽게 정의하기 위해 제공되는 함수
* OVER 절이 들어간 함수
* 순위함수 : 결과에 순번 또는 순위를 매기는 역할을 하는 함수

```SQL
-- 순위함수 기본 구문
<순위함수이름>() OVER(
    [PARTITION BY <parition_by_list>]
    ORDER BY <order_by_list>
    )

-- ROW_NUMBER() : 키가 큰 순으로 순위 정하는 쿼리문 : userTBL(height)
SELECT ROW_NUMBER() OVER(ORDER BY height DESC) "키큰순위", name, addr, height
  FROM userTBL;
  
-- ROW_NUMBER(ORDER BY name ASC) : 키가 동일한 경우 이름순으로 정렬  
SELECT ROW_NUMBER() OVER(ORDER BY height DESC, name ASC) "키큰순위", name, addr, height
  FROM userTBL;

-- ROW_NUMBER(PARTITION) : 지역별 키 큰 순위 정하는 쿼리문
SELECT addr, ROW_NUMBER() OVER(PARTITION BY addr ORDER BY height DESC, name ASC) "키큰순위", name, height
  FROM userTBL;
  
-- DENSE_RANK() : 키가 같은 경우 동일한 순위로 처리 (동일 순위 다음 순위 : 2등 2명인 경우 3등으로 처리)
SELECT DENSE_RANK() OVER(ORDER BY height DESC) "키큰순위", name, addr, height
  FROM userTBL;

-- RANK() : 키가 같은 경우 동일한 순위로 처리 (동일 순위 다음 순위 : 2등 2명인 경우 4등으로 처리)
SELECT RANK() OVER(ORDER BY height DESC) "키큰순위", name, addr, height
  FROM userTBL;
  
-- NTILE() : 몇 개의 그룹으로 분할
SELECT NTILE(2) OVER(ORDER BY height DESC) "반번호", name, addr, height
  FROM userTBL;
```

* 분석함수 : 이동평균, 백분율, 누계 등의 결과 계산

```SQL
-- 다음, 이전 사람과 키 차이 조회
SELECT name, addr, height,
		height - (LEAD(height, 1) OVER (ORDER BY height DESC)) AS "다음 사람과 키 차이",
		height - (LAG(height, 1) OVER (ORDER BY height DESC)) AS "이전 사람과 키 차이"
  FROM userTBL;		

-- [참고만] 지역별 가장 키가 큰 사람과의 차이 조회
SELECT addr, name, height,
		height - (FIRST_VALUE(height) OVER (PARTITION BY addr ORDER BY height DESC)) AS "지역별 최대키와 차이",
		height - (FIRST_VALUE(height) OVER (PARTITION BY addr ORDER BY height ASC)) AS "지역별 최소키와 차이"
  FROM userTBL;		
  
-- [참고만] CUME_DIST() : 누적합계, 지역별 자신보다 키가 같거나 큰 인원의 백분율
SELECT addr, name, height,
	CUME_DIST() OVER (PARTITION BY addr ORDER BY height DESC)
  FROM userTBL;	
```



# [실습 12 : 28 ~ 30p]

### 7.2.3 피벗과 JSON

* 피벗의 구현 : 여러 row를 컬럼의 값으로 변환하고, 필요시 집계까지 수행하는 것

```SQL
-- 테이블 생성 : pivotTest
USE sqlDB;
CREATE TABLE pivotTest(
    pName CHAR(3),
    season CHAR(2),
    amount INT
);

-- 데이타 입력
INSERT INTO pivotTest VALUES
('TV', '1', 10), ('TV', '2', 20), ('TV', '2', 15), ('TV' ,'4' ,25),
('세탁기', '1', 5), ('세탁기', '3', 10),('세탁기', '3', 15), ('세탁기', '4', 20),
('에어컨', 2, 20), ('에어컨', 3, 10)
;

-- 데이타 확인
SELECT * FROM pivotTest;

-- STEP1 : 행과 열 모두 출력
SELECT	pName,
		amount,
		amount,
		amount,
		amount
  FROM pivotTest;
  
-- STEP2 : 열에 분기 조건 추가  
SELECT	pName,
		IF(season='1',amount,0) AS '1분기',
		IF(season='2',amount,0) AS '2분기',
		IF(season='3',amount,0) AS '3분기',
		IF(season='4',amount,0) AS '4분기',
		amount AS '함계'
  FROM pivotTest;

-- STEP3 : GROUP BY로 피벗 형태 출력 확인
SELECT pName AS '제품명',
	SUM(IF(season='1', amount, 0)) AS '1분기',
	SUM(IF(season='2', amount, 0)) AS '2분기',
	SUM(IF(season='3', amount, 0)) AS '3분기',
	SUM(IF(season='4', amount, 0)) AS '4분기',
	SUM(amount) AS '합계'
  FROM pivotTest
GROUP BY pName;                
```

* JSON 데이터

  { "ID" : "1001", name" : "KIM"}

```SQL
-- JSON_OBJECT() : 쿼리 결과 json 형태로 변경
SELECT JSON_OBJECT('name', name, 'height', height) AS 'JSON 값'
  FROM userTBL
 where HEIGHT >= 180;
```

* [참고만] JSON 관련 함수

```SQL
SET @json='{"userTBL" :
[
    {"name":"KIM", "height":182},
    {"name":"LEE", "height":182},
    {"name":"PARK", "height":186}
]
}';

SELECT JSON_VALID(@json);  - 1인 경우 json 타입임
SELECT JSON_SEARCH(@json, 'one', 'KIM'); -- one 검색한 첫번째 결과만 리턴, all 검색한 모든 결과
SELECT JSON_EXTRACT(@json, '$.userTBL[2].name');
SELECT JSON_INSERT(@json, '$.userTBL[0].mDate', '2022-10-01');
SELECT JSON_REPLACE(@json, '$.userTBL[0].name', 'HONG');
SELECT JSON_REMOVE(@json, '$.userTBL[0]');
```
