# [실습 1 : 5 ~ 8p]

## 10.1 스토어드 프로시저

* 스토어드 프로시저 생성

```SQL
-- userTBL 데이타 조회 프로시저
USE SQLDB;
DELIMITER $$
CREATE OR REPLACE PROCEDURE userProc()
BEGIN

	SELECT USERID FROM userTBL;

END $$
DELIMITER ;

-- 프로시저 실행
CALL userProc;
```

* 스토어드 프로시저의 삭제

```SQL
-- 프로시저 삭제
DROP PROCEDURE userProc;
```

* 입력 매개변수가 있는 스토어드 프로시저

```SQL
-- 프로시저 userProc1 생성
USE sqlDB;
DROP PROCEDURE IF EXISTS userProc1;
DELIMITER $$

CREATE PROCEDURE userProc1(IN userName VARCHAR(10))
BEGIN
	SELECT * FROM userTBL WHERE name = userName;
END $$

DELIMITER ;

-- 프로시저 userProc1 실행
CALL userProc1('성시경')
```

* 출력 매개변수가 있는 스토어드 프로시저

  : testTBL(id와 txt 두개의 컬럼을 가짐)에 txt 를 인자로 받아 insert 하고 max(id)를 반환하는 프로시저

  : id는 auto_increment

```SQL
-- 테이블 생성 : testTBL
CREATE TABLE IF NOT EXISTS testTBL(
    id INT AUTO_INCREMENT PRIMARY KEY,
    txt VARCHAR(10)
);

-- 프로시저 userProc2 생성
USE sqlDB;
DROP PROCEDURE IF EXISTS userProc2;
DELIMITER $$
CREATE PROCEDURE userProc2(
    IN txtValue VARCHAR(10),
    OUT outValue INT
)
BEGIN
	INSERT INTO testTBL VALUES(NULL, txtValue);
	SELECT MAX(id) INTO outValue FROM testTBL;
END $$
DELIMITER ;

-- 프로시저 userProc2 실행
CALL userProc2('테스트값', @myValue);
SELECT CONCAT('현재 입력된 ID 값 ==> ', @myValue);
```

* 저장된 프로시저의 이름 및 내용 확인

```SQL
-- 아래 명령어로 다양하게 확인 가능, HeidiSQL로 확인이 편리함
SELECT routine_name, routine_definition
  FROM INFORMATION_SCHEMA.ROUTINES
 WHERE routine_schema = 'sqldb' AND routine_type = 'PROCEDURE';
 
-- SELECT routine_name, routine_definition
--   FROM INFORMATION_SCHEMA.PARAMETERS
-- WHERE routine_schema = 'sqldb' AND routine_type = 'PROCEDURE';
 
SELECT param_list, body FROM MYSQL.PROC
 WHERE db='sqldb' AND type='PROCEDURE' AND name='userProc2';
 
SHOW CREATE PROCEDURE sqldb.userProc2; 
```

* 구구단을 문자열로 출력하는 프로시저 : 2중 반복문 사용

```SQL
DROP PROCEDURE IF EXISTS whileProc;
DELIMITER $$
CREATE PROCEDURE whileProc()
BEGIN

DECLARE str VARCHAR(1000) DEFAULT '';
DECLARE i INT DEFAULT 1;
DECLARE j INT DEFAULT 0;

WHILE i < 9 DO
	SET str = '';
	SET i = i + 1;
	
	SET j = 0;
	WHILE j < 9 DO
		SET j = j + 1;
		SET str = CONCAT(str, ' ', i, '*', j, '=', i*j);
	END WHILE;
	
	SELECT str;
END WHILE;

END $$
DELIMITER ;

CALL whileProc();
```



# [실습 2 : 9 ~ 10p]

## 10.2 스토어드 함수

* 스토어드 함수 생성 및 호출

```SQL
USE sqlDB;
DROP FUNCTION IF EXISTS userFunc;
DELIMITER $$
CREATE FUNCTION userFunc(value1 INT, value2 INT)
	RETURNS INT
BEGIN
	RETURN value1 + value2;
END $$
DELIMITER ;

SELECT userFunc(100, 200);
```

* 출생연도 입력 시 나이가 출력되는 함수 생성

```SQL
-- 함수 생성
USE sqlDB;
DROP FUNCTION IF EXISTS getAgeFunc;
DELIMITER $$
CREATE FUNCTION getAgeFunc(bYear INT)
	RETURNS INT
BEGIN
	DECLARE age INT;
	SET age = YEAR(CURDATE()) - bYear;
	RETURN age;
END $$
DELIMITER ;

-- 함수 호출
SELECT getAgeFunc(1979);

-- 함수 변환 값 저장 후 사용
SELECT getAgeFunc(1979) INTO @age1;
SELECT getAgeFunc(1997) INTO @age2;
SELECT @age1 - @age2;
```

* userTBL에서 birtyYear로 나이 조회하기

```SQL
SELECT userID, name, birthYear, getAgeFunc(birthYear) AS 나이 FROM userTBL;
```

* 저장된 함수의 이름 및 내용 확인

```SQL
-- 아래 명령어로 다양하게 확인 가능, HeidiSQL로 확인이 편리함
SELECT routine_name, routine_definition
  FROM INFORMATION_SCHEMA.ROUTINES
 WHERE routine_schema = 'sqldb' AND routine_type = 'FUNCTION';
 
SELECT param_list, body FROM MYSQL.PROC
 WHERE db='sqldb' AND type='FUNCTION' AND name='getAgeFunc';
```



# [실습 3 : 11 ~ 12p] : p432 ~ 435

## 10.3 커서

* 커서를 활용한 고객의 평균 키 구하기

```SQL
DROP PROCEDURE IF EXISTS cursorProc;
DELIMITER $$
CREATE PROCEDURE cursorProc()
BEGIN

-- 변수 선언문
	DECLARE userHeight INT;
	DECLARE cnt	INT DEFAULT 0;
	DECLARE totalHeight INT DEFAULT 0;
	
-- 행의 끝 부분 처리문 선언
-- DECLARE [CONTINUE|EXIT] HANDLER FOR 오류조건 처리할 문장 (처리 문장이 여러 개인 경우 BEGIN --- END 사용)
	DECLARE end0Row BOOLEAN DEFAULT FALSE;

-- 1. 커서 선언
	DECLARE userCursor CURSOR FOR
		SELECT height FROM userTBL;

	DECLARE CONTINUE HANDLER
		FOR NOT FOUND SET end0Row = TRUE;
		
-- 2. 커서 OPEN		
	OPEN userCursor;
	
-- 3. Fetch / 데이타처리
	cursor_loop: LOOP
	
		FETCH userCursor INTO userHeight;
		
		-- 행의 끝 부분에 도달 시 cursor_loop 빠져나가기		
		IF end0Row THEN
			LEAVE cursor_loop;
		END IF;
		
		SET cnt = cnt + 1;
		SET totalHeight = totalHeight + userHeight;
		
	END LOOP cursor_loop;

	SELECT CONCAT('키 평균 ==> ', (totalHeight/cnt));
                  
-- 4. 커서 CLOSE                  
	CLOSE userCursor;
END $$
DELIMITER ;

-- 프로시저 실행
CALL cursorProc();
```

* 커서를 활용한 고객 등급 부여하기

  : buytbl의 price*amout 값이 1500 이상이면 VVIP, 100 이상이면 VIP, 구매이력 있으면 일반, 없으면 GHOST 등급을
   usertbl의 grade 컬럼에 update하고, totalamt 컬럼에 총액을 update하기

```SQL
-- userTBL에 grade 컬럼 추가
USE sqlDB;
ALTER TABLE userTBL ADD grade VARCHAR(10);
ALTER TABLE userTBL ADD totalamt INT;

-- 프로시저 생성
DROP PROCEDURE IF EXISTS gradeProc;
DELIMITER $$
CREATE PROCEDURE gradeProc()
BEGIN

-- 변수 선언문
	DECLARE id VARCHAR(10);
	DECLARE hap BIGINT;
	DECLARE userGrade VARCHAR(10);
	
-- 행의 끝 부분 처리문 선언
	DECLARE end0Row BOOLEAN DEFAULT FALSE;

-- 1. 커서 선언
	DECLARE userCursor CURSOR FOR
		SELECT U.userid, nvl(sum(price*amount),0)
		  FROM buyTBL B
		  		RIGHT OUTER JOIN userTBL U
		  		ON B.userID = U.userID
		GROUP BY U.userid;		  		

	DECLARE CONTINUE HANDLER
		FOR NOT FOUND SET end0Row = TRUE;
		
-- 2. 커서 OPEN		
	OPEN userCursor;
	
-- 3. Fetch / 데이타처리
	cursor_loop: LOOP
	
		FETCH userCursor INTO id, hap;
		
		-- 행의 끝 부분에 도달 시 cursor_loop 빠져나가기		
		IF end0Row THEN
			LEAVE cursor_loop;
		END IF;
		
		-- 처리문
		IF hap >= 1500 THEN
			SET userGrade = 'VVIP';        
		ELSEIF hap >= 1000 THEN
			SET userGrade = 'VIP';
		ELSEIF hap >=1 THEN
			SET userGrade = 'NORMAL';
		ELSE
			SET userGrade = 'GHOST';
        END IF;
        
        UPDATE userTBL SET grade = userGrade, totalamt = hap WHERE trim(userID) = trim(id);
       
	END LOOP cursor_loop;
                
-- 4. 커서 CLOSE                  
	CLOSE userCursor;
END $$
DELIMITER ;

-- 프로시저 실행
CALL gradeProc();
SELECT * FROM userTBL;
```



# [실습 4 : 13 ~ 14p]

## 10.4 트리거

* 트리거 생성 및 데이타 CUD 실행

```SQL
-- 테이블 생성 및 데이타 입력
USE sqlDB;
CREATE TABLE IF NOT EXISTS testTbl (id INT, txt VARCHAR(10));
INSERT INTO testTbl VALUES(1, '이엑스아이디');
INSERT INTO testTbl VALUES(2, '에프터스쿨');
INSERT INTO testTbl VALUES(3, '에이오에이');

-- 트리거 생성 : testTBL 데이터 DELETE 시 msg 변수에 '삭제' 대입
DROP TRIGGER IF EXISTS testTrg;
DELIMITER //
CREATE TRIGGER testTrg
	AFTER DELETE
	ON testTbl
	FOR EACH ROW
BEGIN
	SET @msg = '삭제';
END //
DELIMITER ;

-- 데이타 CUD 수행
INSERT INTO testTbl VALUES(4, '나인뮤직스');
SELECT @msg;
UPDATE testTbl SET txt = '에이핑크' WHERE id = 3;
SELECT @msg;
DELETE FROM testTbl WHERE id = 4;
SELECT @msg;
```



# [실습 5 : 15p]

* AFTER 트리거의 사용 : UPDATE / DELETE

   : 회원테이블의 수정, 삭제 시 별도 테이블에 원본 데이타 보관하고 변경일자, 변경한 사람 기록

```SQL
-- backup_userTBL 생성
USE sqlDB;
DROP TABLE buyTBL; -- 외래키로 아래 실습 시 삭제 필요
CREATE TABLE backup_userTBL( 
    userID char(8) NOT NULL PRIMARY KEY,
    name varchar(10) NOT NULL,
    birthYear int NOT NULL,
    addr char(2) NOT NULL,
    mobile1 char(3),
    mobile2 char(8),
    height smallint,
    mDate date,
    mopdType char(2),
    modDate date,
    modUser varchar(256)
);

-- UPDATE 트리거 생성
DROP TRIGGER IF EXISTS backUserTbl_UpdateTrg;
DELIMITER //
CREATE TRIGGER backUserTbl_UpdateTrg
	AFTER UPDATE
	ON userTBL
	FOR EACH ROW
BEGIN
	INSERT INTO backup_userTBL VALUES(
        OLD.userID, OLD.name, OLD.birthYear, OLD.addr, OLD.mobile1, OLD.mobile2,
        OLD.height, OLD.mDate, '수정', CURDATE(), CURRENT_USER()
    );

END //
DELIMITER ;

-- 데이터 변경, 삭제 후 백업테이블 확인
UPDATE userTBL SET addr = '몽고' WHERE userID = 'JKW';
SELECT * FROM backup_userTBL;

-- DELETE 트리거 생성
DROP TRIGGER IF EXISTS backUserTbl_DeleteTrg;
DELIMITER //
CREATE TRIGGER backUserTbl_DeleteTrg
	AFTER DELETE
	ON userTbl
	FOR EACH ROW

BEGIN
	INSERT INTO backup_userTBL VALUES(
        OLD.userID, OLD.name, OLD.birthYear, OLD.addr, OLD.mobile1, OLD.mobile2,
        OLD.height, OLD.mDate, '삭제', CURDATE(), CURRENT_USER()
    );

END //
DELIMITER ;

-- 데이터 변경, 삭제 후 백업테이블 확인
UPDATE userTBL SET addr = '몽고' WHERE userID = 'JKW';
DELETE FROM userTBL WHERE height >= 177;
SELECT * FROM backup_userTBL;
```

* TRUNCATE TABLE 시에는 트리거 작동 불가

  

# [실습 6 : 16p]

* BEFORE 트리거의 사용

  : 테이블에 변경이 가해지기 전에 데이타 값 확인 및 변경후 적용 가능

* 출생연도 1900년 미만인 경우 0이 입력되도록 하는 트리거 생성

```SQL
-- 출생 연도가 1900면 미만인 경우 0으로 변경, 
-- 출생 연도가 현재 연도보다 크면 현재 연도로 변경
USE sqlDB;
DROP TRIGGER IF EXISTS userTbl_BeforeInsertTrig;
DELIMITER //
CREATE TRIGGER userTbl_BeforeInsertTrig
	BEFORE INSERT
	ON userTbl
	FOR EACH ROW
BEGIN

	IF NEW.birthYear < 1900 THEN
		SET NEW.birthYear = 0;
	ELSEIF NEW.birthYear > YEAR(CURDATE()) THEN
		SET NEW.birthYear = YEAR(CURDATE());
	END IF;
END //
DELIMITER ;

-- userTBL에 데이타 입력
INSERT INTO userTBL(userID, name, birthYear, addr, mobile1, mobile2, height, mDate)
VALUES ('AAA', '에이', 1877, '서울', '010', '1112222', 181, '2019-12-25');
INSERT INTO userTBL(userID, name, birthYear, addr, mobile1, mobile2, height, mDate)
VALUES ('BBB', '비이', 2877, '경기', '010', '1113333', 171, '2011-12-25');
INSERT INTO userTBL(userID, name, birthYear, addr, mobile1, mobile2, height, mDate)
VALUES ('CCC', '씨이', 1977, '인천', '010', '1114444', 175, '2013-12-25');
```

* 트리거 확인 및 삭제

```SQL
-- sqlDB의 전체 트리거 확인
SHOW TRIGGERS FROM sqlDB;

-- 트리거 삭제
DROP TRIGGER userTbl_BeforeInsertTrig;
```
